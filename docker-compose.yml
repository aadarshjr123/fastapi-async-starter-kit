version: "3.9"
services:
  db:
    image: postgres:14
    environment:
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
      POSTGRES_DB: mydb
    ports:
      - "5432:5432"
    volumes:
      - ./pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U myuser -d mydb -h localhost"]
      interval: 2s
      timeout: 2s
      retries: 20

  web:
    build: .
    ports:
      - "8000:8000"
      - "8080:8080"
    volumes:
      - .:/app
      - "D:/My code/software engineer/LeetCode/projects/fastapi-jwt-sqlite/profiles:/profiles"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    environment:
      - PROFILE=1 

  pgadmin:
    image: dpage/pgadmin4
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@admin.com
      PGADMIN_DEFAULT_PASSWORD: admin
    ports:
      - "5050:80"
    depends_on:
      - db

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
  

  

# explanation
# This docker-compose.yml file defines two services: 'web' and 'db'.
# The 'web' service builds from the current directory, maps port 8000 on the host to port 8000 in the container, and mounts the current directory to /app in the container. It also depends on the 'db' service.
# The 'db' service uses the official PostgreSQL 14 image, sets environment variables for the database user, password, and name, maps port 5432 on the host to port 5432 in the container, and mounts a volume for persistent data storage.
# This setup is useful for a web application that requires a PostgreSQL database.


